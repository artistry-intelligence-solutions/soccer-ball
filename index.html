<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <title></title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="">
  <meta property="og:type" content="">
  <meta property="og:url" content="">
  <meta property="og:image" content="">

  <link rel="manifest" href="site.webmanifest">
  <link rel="apple-touch-icon" href="icon.png">
  <!-- Place favicon.ico in the root directory -->

  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/styles.css">

  <meta name="theme-color" content="#fafafa">
</head>

<body>
  <script type="module">
    // https://github.com/tweenjs/tween.js/
    import * as THREE from './node_modules/three/build/three.module.js';
    import { GUI } from './node_modules/three/examples/jsm/libs/dat.gui.module.js';
    import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';
    import Stats from './node_modules/three/examples/jsm/libs/stats.module.js';

    const params = {
      enableWind: true,
      showBall: false,
      togglePins: togglePins
    };

    const mass = 0.1;
    const restDistance = 25;
    const xSegs = 10;
    const ySegs = 10;
    
    const ballSize = 60;
    const ballPosition = new THREE.Vector3(0, -190, 0);
    const clothFunction = plane(restDistance * xSegs, restDistance * ySegs);
    const cloth = new Cloth(xSegs, ySegs);
    const damping = 0.03;
    const drag = 1 -damping;
    const gravityVector = 981 * 1.4;
    const gravity = new THREE.Vector3(0, -gravityVector, 0).multiplyScalar(mass);
    const loader = new THREE.TextureLoader();
    const timestep = 18 / 1000;
    const timestepSq = timestep * timestep;
    const windForce = new THREE.Vector3(0, 0, 0);

    let camera;
    let clothGeometry;
    let container;
    let controls;
    let object;
    let pins = [ 6 ];
    let pinsFormation = [];
    let renderer = new THREE.WebGLRenderer();
    let scene = new THREE.Scene();
    let sphere;
    let stats;

    pinsFormation.push( pins );
    pins = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
    pinsFormation.push( pins );
    pins = [ 0 ];
    pinsFormation.push( pins );
    pins = []; // cut the rope ;)
    pinsFormation.push( pins );
    pins = [ 0, cloth.w ]; // classic 2 pins
    pinsFormation.push( pins );
    pins = pinsFormation[ 1 ];

    init();
    animate(0);

    document.addEventListener('keydown', mapKeys, false);

    function animate(now) {
      requestAnimationFrame(animate);
      // simulate(now);
      render();
      controls.update();
      stats.update();
    }

    function Cloth( w, h ) {
      w = w || 10;
      h = h || 10;
      this.w = w;
      this.h = h;

      var particles = [];
      var constraints = [];
      var u, v;

      // Create particles
      for ( v = 0; v <= h; v ++ ) {
        for ( u = 0; u <= w; u ++ ) {
          particles.push(
            new Particle( u / w, v / h, 0, mass )
          );
        }
      }

      // Structural
      for ( v = 0; v < h; v ++ ) {
        for ( u = 0; u < w; u ++ ) {
          constraints.push( [
            particles[ index( u, v ) ],
            particles[ index( u, v + 1 ) ],
            restDistance
          ] );
          constraints.push( [
            particles[ index( u, v ) ],
            particles[ index( u + 1, v ) ],
            restDistance
          ] );
        }
      }

      for ( u = w, v = 0; v < h; v ++ ) {
        constraints.push( [
          particles[ index( u, v ) ],
          particles[ index( u, v + 1 ) ],
          restDistance
        ] );
      }

      for ( v = h, u = 0; u < w; u ++ ) {
        constraints.push( [
          particles[ index( u, v ) ],
          particles[ index( u + 1, v ) ],
          restDistance
        ] );
      }

      this.particles = particles;
      this.constraints = constraints;

      function index( u, v ) {

        return u + v * ( w + 1 );

      }

      this.index = index;
    }

    function init() {
      container = document.createElement('div');
      document.body.appendChild(container);

      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xcce0ff);
      scene.fog = new THREE.Fog(0xcce0ff, 500, 10000);

      // Camera
      camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 100, 10000);
      // camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
      camera.position.set( 1000, 50, 1500 );
      camera.lookAt(scene.position);

      // Lights
      scene.add(new THREE.AmbientLight(0x666666));

      const light = new THREE.DirectionalLight(0xdfebff, 1);
      light.position.set(50, 200, 100);
      light.position.multiplyScalar(1.3);

      light.castShadow = true;
      light.shadow.mapSize.width = 1024;
      light.shadow.mapSize.height = 1024;

      const d = 300;

      light.shadow.camera.left = -d;
      light.shadow.camera.right = d;
      light.shadow.camera.top = d;
      light.shadow.camera.bottom = -d;

      light.shadow.camera.far = 10000;
      
      scene.add(light);

      const loader = new THREE.TextureLoader();

      // soccerball texture: https://github.com/jeromeetienne/threex.sportballs
      const ballGeo = new THREE.SphereBufferGeometry(ballSize, 32, 32);
      const ballMaterial = new THREE.MeshLambertMaterial({
        // color: 0xf70000,
        map: loader.load('img/soccerball.jpg'),
        reflectivity: 1,
        reflectivityRatio: 1
      });

      sphere = new THREE.Mesh(ballGeo, ballMaterial);
      sphere.position.set(0, -190, 0);
      // sphere.position.set(0, -15, 0);
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      sphere.visible = true;
      sphere.name = 'soccerball';
      // sphere.add(camera);
      scene.add(sphere);
      
      const groundTexture = loader.load('img/grass.jpg');
      groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
      groundTexture.repeat.set(25, 25);
      groundTexture.anisotropy = 16;
      groundTexture.encoding = THREE.sRGBEncoding;

      const groundMaterial = new THREE.MeshLambertMaterial({
        map: groundTexture
      });

      const mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry(20000, 20000), groundMaterial);
      mesh.position.y = -250;
      mesh.rotation.x = -Math.PI / 2;
      mesh.receiveShadow = true;
      scene.add(mesh);

      renderer = new THREE.WebGLRenderer({
        antialias: true
      });

      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.shadowMap.enabled = true;

      controls = new OrbitControls(camera, renderer.domElement);
      controls.dampingFactor = 0.05;
      controls.enableDamping = true;
      controls.maxDistance = 1200;
      controls.maxPolarAngle = Math.PI * 0.5;
      controls.minDistance = 800;
      controls.screenSpacePanning = true;
      controls.target.copy(sphere.position);

      stats = new Stats();
      container.appendChild(stats.dom);

      window.addEventListener( 'resize', onWindowResize, false );

      const gui = new GUI();
      gui.add(params, 'showBall').name('Show Ball');

      console.log(scene);
    }

    function mapKeys(event) {
      //   // w - 87
      //   // a - 65
      //   // s - 83
      //   // d - 68
      //   // space - 32
      const soccerBall = scene.getObjectByName('soccerball');
      if (event.code == 'KeyW') {
        sphere.position.x += -5;
        sphere.rotation.x += -0.05;
        camera.position.x += -5;
        render(scene);
      } else if (event.code == 'KeyA') {
        sphere.position.z += 5;
        sphere.rotation.z += 0.05;
        camera.position.z += 5;
        render(scene);
      } else if (event.code == 'KeyS') {
        sphere.position.x += 5;
        sphere.rotation.x += 0.05;
        camera.position.x += 5;
        render(scene);
      } else if (event.code == 'KeyD') {
        sphere.position.z += -5;
        sphere.rotation.z += -0.05;
        camera.position.z += -5;
        render(scene);
      } else {
        console.log('couldn\'t detect a key event');
      }
    }

    // function cameraUpdate() {
    //   //creating an offset position for camera with respect to the car
    //   const offset = new THREE.Vector3(sphere.position.x + 20, sphere.position.y + 6, sphere.position.z);
    //   //tried to create delay position value for enable smooth transition for camera 
    //   camera.position.lerp(offset, 0.2);
    //   //updating lookat alway look at the car
    //   camera.lookAt(sphere.position.x, sphere.position.y, sphere.position.z); 
    // }

    function Particle( x, y, z, mass ) {
      this.position = new THREE.Vector3();
      this.previous = new THREE.Vector3();
      this.original = new THREE.Vector3();
      this.a = new THREE.Vector3( 0, 0, 0 ); // acceleration
      this.mass = mass;
      this.invMass = 1 / mass;
      this.tmp = new THREE.Vector3();
      this.tmp2 = new THREE.Vector3();

      // init
      clothFunction( x, y, this.position );
      clothFunction( x, y, this.previous );
      clothFunction( x, y, this.original );
    }

    function plane(height, width) {
      return function(u, v, target) {
        const x = (u - 0.5) * width;
        const y = (v + 0.5) * height;
        const z = 0;
        target.set(x, y, z);
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth /window.innerHeight;
      camera.updateProjectionMatrix();      
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function render() {
      // sphere.position.copy(ballPosition);
      renderer.render(scene, camera);
    }

    function togglePins() {
      pins = pinsFormation[ ~ ~ (Math.random() * pinsFormation.lenght)];
    }
  </script>
</body>

</html>
